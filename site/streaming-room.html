<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Private Streaming Room</title>
  <style>
    body {
      margin: 0; padding: 0;
      font-family: monospace;
      background: #f2e38f;
      display: flex;
      height: 100vh;
      flex-direction: column;
      align-items: center;
    }

    #container {
      max-width: 900px;
      width: 100%;
      display: flex;
      flex-grow: 1;
      gap: 20px;
      padding: 20px;
      box-sizing: border-box;
    }

    #video-section {
      flex: 2;
      background: white;
      border: 4px solid black;
      display: flex;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
      position: relative;
      min-height: 400px;
    }

    #remoteVideo {
      width: 100%;
      height: 100%;
      background: black;
      object-fit: contain;
      border: 2px solid black;
    }

    #streamer-info {
      font-weight: bold;
      margin-bottom: 10px;
    }

    #btn-share {
      margin-top: 10px;
      padding: 10px 20px;
      font-family: monospace;
      font-weight: bold;
      border: 4px solid black;
      background: black;
      color: #f2e38f;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s ease, color 0.3s ease;
      max-width: 200px;
    }
    #btn-share:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    #btn-share:hover:not(:disabled) {
      background: #f5de5d;
      color: black;
    }

    #chat-section {
      flex: 1;
      background: white;
      border: 4px solid black;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      height: 100%;
      max-height: 600px;
      overflow: hidden;
    }

    #user-list {
      background: #ddd;
      border-bottom: 2px solid black;
      padding: 5px 10px;
      font-weight: bold;
      min-height: 40px;
      user-select: none;
    }

    #chat-messages {
      flex-grow: 1;
      padding: 10px;
      overflow-y: auto;
      font-size: 14px;
      font-family: monospace;
      background: #f9f9f9;
      border-bottom: 2px solid black;
    }

    #chat-input-area {
      display: flex;
      padding: 10px;
      gap: 8px;
      box-sizing: border-box;
      border-top: 2px solid black;
      background: #eee;
    }

    #chat-username {
      width: 100px;
      padding: 6px;
      border: 3px solid black;
      font-family: monospace;
      text-transform: capitalize;
      font-weight: bold;
    }

    #chat-message-input {
      flex-grow: 1;
      padding: 6px;
      border: 3px solid black;
      font-family: monospace;
    }

    #chat-send-btn {
      padding: 6px 20px;
      background: black;
      color: #f2e38f;
      font-weight: bold;
      border: none;
      cursor: pointer;
      font-family: monospace;
      user-select: none;
    }
    #chat-send-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    #chat-send-btn:hover:not(:disabled) {
      background: #f5de5d;
      color: black;
    }

    #exit-room {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 10px 20px;
      font-family: monospace;
      font-weight: bold;
      border: 4px solid black;
      background: black;
      color: #f2e38f;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s ease, color 0.3s ease;
      z-index: 1000;
    }
    #exit-room:hover {
      background: #f5de5d;
      color: black;
    }

    #name-entry {
      margin: 30px auto;
      max-width: 400px;
      padding: 20px;
      border: 4px solid black;
      background: white;
      display: flex;
      flex-direction: column;
      gap: 12px;
      font-family: monospace;
    }
    #name-input {
      padding: 10px;
      font-size: 18px;
      border: 4px solid black;
      text-transform: capitalize;
    }
    #join-btn {
      padding: 10px;
      font-family: monospace;
      font-weight: bold;
      border: 4px solid black;
      background: black;
      color: #f2e38f;
      cursor: pointer;
      user-select: none;
      transition: background 0.3s ease, color 0.3s ease;
    }
    #join-btn:hover {
      background: #f5de5d;
      color: black;
    }
  </style>

  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
</head>
<body>

  <!-- Name entry dialog -->
  <div id="name-entry">
    <label for="name-input">Enter your name to join:</label>
    <input type="text" id="name-input" placeholder="Your name" autofocus />
    <button id="join-btn" disabled>Join Room</button>
  </div>

  <div id="container" style="display:none;">
    <div id="video-section">
      <div id="streamer-info">No one is streaming currently.</div>
      <video id="remoteVideo" autoplay playsinline></video>
      <button id="btn-share" disabled>Start Sharing Screen</button>
    </div>

    <div id="chat-section">
      <div id="user-list">Users: <span id="user-names">â€”</span></div>
      <div id="chat-messages"></div>
      <div id="chat-input-area">
        <input id="chat-username" disabled />
        <input id="chat-message-input" placeholder="Type a message..." />
        <button id="chat-send-btn" disabled>Send</button>
      </div>
    </div>
  </div>

  <button id="exit-room" style="display:none;">Exit Room</button>

  <script>
    // Your Firebase config (replace with your real config)
    const firebaseConfig = {
      databaseURL: "https://criss-chat-default-rtdb.firebaseio.com/",
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // Constants
    const ROOM_ID = 'criss-private-room'; // fixed room for you two, or generate dynamic
    const usersRef = db.ref(`rooms/${ROOM_ID}/users`);
    const signalingRef = db.ref(`rooms/${ROOM_ID}/signaling`);
    const chatRef = db.ref(`rooms/${ROOM_ID}/chat`);
    const streamingRef = db.ref(`rooms/${ROOM_ID}/streaming`);

    // UI Elements
    const nameEntry = document.getElementById('name-entry');
    const nameInput = document.getElementById('name-input');
    const joinBtn = document.getElementById('join-btn');
    const container = document.getElementById('container');
    const remoteVideo = document.getElementById('remoteVideo');
    const btnShare = document.getElementById('btn-share');
    const streamerInfo = document.getElementById('streamer-info');
    const chatMessages = document.getElementById('chat-messages');
    const chatUsernameInput = document.getElementById('chat-username');
    const chatMessageInput = document.getElementById('chat-message-input');
    const chatSendBtn = document.getElementById('chat-send-btn');
    const userListSpan = document.getElementById('user-names');
    const exitBtn = document.getElementById('exit-room');

    // State
    let localStream = null;
    let peerConnection = null;
    let isStreaming = false;
    let username = '';
    let userId = null;

    // WebRTC config (Google STUN servers)
    const rtcConfig = {
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    };

    // Enable Join button only if name entered
    nameInput.addEventListener('input', () => {
      joinBtn.disabled = !nameInput.value.trim();
    });

    joinBtn.onclick = async () => {
      username = nameInput.value.trim();
      userId = 'user_' + Math.random().toString(36).substr(2, 9);
      nameEntry.style.display = 'none';
      container.style.display = 'flex';
      exitBtn.style.display = 'block';
      chatUsernameInput.value = username;
      chatUsernameInput.disabled = true;

      // Add user to users list in DB
      await usersRef.child(userId).set({ username, joinedAt: Date.now() });
      // Remove user on disconnect
      usersRef.child(userId).onDisconnect().remove();

      setupChat();
      setupSignaling();
      updateUserList();

      // Listen if someone is streaming and update UI
      streamingRef.on('value', snapshot => {
        const data = snapshot.val();
        if(data && data.streamerId){
          streamerInfo.textContent = `Streaming now: ${data.streamerName}`;
          if(data.streamerId === userId){
            btnShare.textContent = 'Stop Sharing Screen';
            btnShare.disabled = false;
            isStreaming = true;
          } else {
            btnShare.textContent = 'Streaming by ' + data.streamerName;
            btnShare.disabled = true;
            isStreaming = false;
          }
        } else {
          streamerInfo.textContent = 'No one is streaming currently.';
          btnShare.textContent = 'Start Sharing Screen';
          btnShare.disabled = false;
          isStreaming = false;
        }
      });
    };

    exitBtn.onclick = async () => {
      if(isStreaming) stopStreaming();
      await usersRef.child(userId).remove();
      await signalingRef.remove();
      await chatRef.remove();
      await streamingRef.remove();
      location.reload();
    };

    // Chat setup
    function setupChat(){
      // Enable send button only if message input has text
      chatMessageInput.addEventListener('input', () => {
        chatSendBtn.disabled = !chatMessageInput.value.trim();
      });

      chatSendBtn.onclick = () => {
        const msg = chatMessageInput.value.trim();
        if(!msg) return;
        chatRef.push({
          username,
          text: msg,
          timestamp: Date.now()
        });
        chatMessageInput.value = '';
        chatSendBtn.disabled = true;
      };

      chatMessageInput.addEventListener('keydown', e => {
        if(e.key === 'Enter' && !chatSendBtn.disabled){
          chatSendBtn.click();
        }
      });

      // Display chat messages
      chatRef.limitToLast(100).on('child_added', snapshot => {
        const {username: u, text} = snapshot.val();
        const div = document.createElement('div');
        div.textContent = `${u}: ${text}`;
        chatMessages.appendChild(div);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      });
    }

    // Update user list display
    function updateUserList(){
      usersRef.on('value', snapshot => {
        const users = snapshot.val() || {};
        const names = Object.values(users).map(u => u.username);
        userListSpan.textContent = names.join(', ') || 'â€”';
      });
    }

    // WebRTC and signaling
    function setupSignaling(){
      peerConnection = new RTCPeerConnection(rtcConfig);

      peerConnection.onicecandidate = e => {
        if(e.candidate){
          signalingRef.push({
            type: 'candidate',
            candidate: e.candidate.toJSON(),
            sender: userId,
          });
        }
      };

      peerConnection.ontrack = e => {
        remoteVideo.srcObject = e.streams[0];
      };

      // Listen for signaling messages
      signalingRef.on('child_added', async snapshot => {
        const msg = snapshot.val();
        if(msg.sender === userId) return; // ignore own messages

        if(msg.type === 'offer'){
          await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.offer));
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          signalingRef.push({
            type: 'answer',
            answer: answer.toJSON(),
            sender: userId,
          });
        } else if(msg.type === 'answer'){
          await peerConnection.setRemoteDescription(new RTCSessionDescription(msg.answer));
        } else if(msg.type === 'candidate'){
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(msg.candidate));
          } catch(e) {
            console.warn('Error adding ICE candidate', e);
          }
        }
      });
    }

    btnShare.onclick = async () => {
      if(isStreaming){
        stopStreaming();
      } else {
        const streamNow = await streamingRef.once('value').then(snap => snap.val());
        if(streamNow && streamNow.streamerId){
          alert('Someone else is already streaming.');
          return;
        }
        startStreaming();
      }
    };

    async function startStreaming(){
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({video:true, audio:false});
        localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        await signalingRef.remove(); // clear old signaling messages
        signalingRef.push({
          type: 'offer',
          offer: offer.toJSON(),
          sender: userId,
        });
        await streamingRef.set({ streamerId: userId, streamerName: username });
        btnShare.textContent = 'Stop Sharing Screen';
        isStreaming = true;

        localStream.getVideoTracks()[0].onended = () => {
          stopStreaming();
        };
      } catch(e){
        alert('Error starting screen share: ' + e.message);
      }
    }

    async function stopStreaming(){
      if(localStream){
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      peerConnection.close();
      setupSignaling(); // recreate peer connection
      await streamingRef.remove();
      btnShare.textContent = 'Start Sharing Screen';
      isStreaming = false;
      remoteVideo.srcObject = null;
    }
  </script>
</body>
</html>
